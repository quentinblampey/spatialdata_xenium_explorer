{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SpatialData to Xenium Explorer","text":"<p>Converting any <code>SpatialData</code> object into files that can be open by the Xenium Explorer.</p> <p>Xenium Explorer is a registered trademark of 10x Genomics</p> <p>You may also be interested in a pipeline for spatial-omics that uses this conversion to Xenium Explorer: see Sopa.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Conversion of the following data: images, cell boundaries (polygons), transcripts, cell-by-gene table, and cell categories (or observations).</li> <li>Image alignment can be made on the Xenium Explorer, and then the <code>SpatialData</code> object can be updated</li> <li>When working on the <code>SpatialData</code> or <code>AnnData</code> object, new cell categories can be easily and quickly added to the Explorer</li> <li>When selecting cells with the \"lasso tool\" on the Explorer, it's easy to select back these cells on the <code>SpatialData</code> or <code>AnnData</code> object</li> </ul>"},{"location":"api/","title":"Api","text":""},{"location":"api/#spatialdata_xenium_explorer.write","title":"<code>spatialdata_xenium_explorer.write(path, sdata, image_key=None, shapes_key=None, points_key=None, gene_column=None, pixel_size=0.2125, spot=False, layer=None, polygon_max_vertices=13, lazy=True, ram_threshold_gb=4, mode=None)</code>","text":"<p>Transform a SpatialData object into inputs for the Xenium Explorer. After running this function, double-click on the <code>experiment.xenium</code> file to open it.</p> <p>Software download</p> <p>Make sure you have the latest version of the Xenium Explorer</p> Note <p>This function will create up to 6 files, depending on the <code>SpatialData</code> object and the arguments:</p> <ul> <li> <p><code>experiment.xenium</code> contains some experiment metadata. Double-click on this file to open the Xenium Explorer. This file can also be created with <code>write_metadata</code>.</p> </li> <li> <p><code>morphology.ome.tif</code> is the primary image. This file can also be created with <code>write_image</code>. Add more images with <code>align</code>.</p> </li> <li> <p><code>analysis.zarr.zip</code> contains the cells categories (or clusters), i.e. <code>adata.obs</code>. This file can also be created with <code>write_cell_categories</code>.</p> </li> <li> <p><code>cell_feature_matrix.zarr.zip</code> contains the cell-by-gene counts. This file can also be created with <code>write_gene_counts</code>.</p> </li> <li> <p><code>cells.zarr.zip</code> contains the cells polygon boundaries. This file can also be created with <code>write_polygons</code>.</p> </li> <li> <p><code>transcripts.zarr.zip</code> contains transcripts locations. This file can also be created with <code>write_transcripts</code>.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the directory where files will be saved.</p> required <code>sdata</code> <code>SpatialData</code> <p>A <code>SpatialData</code> object.</p> required <code>image_key</code> <code>str | None</code> <p>Name of the image of interest (key of <code>sdata.images</code>). This argument doesn't need to be provided if there is only one image.</p> <code>None</code> <code>shapes_key</code> <code>str | None</code> <p>Name of the cell shapes (key of <code>sdata.shapes</code>). This argument doesn't need to be provided if there is only one shapes key or a table with only one region.</p> <code>None</code> <code>points_key</code> <code>str | None</code> <p>Name of the transcripts (key of <code>sdata.points</code>). This argument doesn't need to be provided if there is only one points key.</p> <code>None</code> <code>gene_column</code> <code>str | None</code> <p>Column name of the points dataframe containing the gene names.</p> <code>None</code> <code>pixel_size</code> <code>float</code> <p>Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.</p> <code>0.2125</code> <code>spot</code> <code>bool</code> <p>Whether the technology is based on spots</p> <code>False</code> <code>layer</code> <code>str | None</code> <p>Layer of <code>sdata.table</code> where the gene counts are saved. If <code>None</code>, uses <code>sdata.table.X</code>.</p> <code>None</code> <code>polygon_max_vertices</code> <code>int</code> <p>Maximum number of vertices for the cell polygons. A higher value will display smoother cells.</p> <code>13</code> <code>lazy</code> <code>bool</code> <p>If <code>True</code>, will not load the full images in memory (except if the image memory is below <code>ram_threshold_gb</code>).</p> <code>True</code> <code>ram_threshold_gb</code> <code>int | None</code> <p>Threshold (in gygabytes) from which image can be loaded in memory. If <code>None</code>, the image is never loaded in memory.</p> <code>4</code> <code>mode</code> <code>str</code> <p>string that indicated which files should be created. \"-ib\" means everything except images and boundaries, while \"+tocm\" means only transcripts/observations/counts/metadata (each letter corresponds to one explorer file). By default, keeps everything.</p> <code>None</code> Source code in <code>spatialdata_xenium_explorer/converter.py</code> <pre><code>def write(\n    path: str,\n    sdata: SpatialData,\n    image_key: str | None = None,\n    shapes_key: str | None = None,\n    points_key: str | None = None,\n    gene_column: str | None = None,\n    pixel_size: float = 0.2125,\n    spot: bool = False,\n    layer: str | None = None,\n    polygon_max_vertices: int = 13,\n    lazy: bool = True,\n    ram_threshold_gb: int | None = 4,\n    mode: str = None,\n) -&gt; None:\n    \"\"\"\n    Transform a SpatialData object into inputs for the Xenium Explorer.\n    After running this function, double-click on the `experiment.xenium` file to open it.\n\n    !!! note \"Software download\"\n        Make sure you have the latest version of the [Xenium Explorer](https://www.10xgenomics.com/support/software/xenium-explorer)\n\n    Note:\n        This function will create up to 6 files, depending on the `SpatialData` object and the arguments:\n\n        - `experiment.xenium` contains some experiment metadata. Double-click on this file to open the Xenium Explorer. This file can also be created with [`write_metadata`](./#spatialdata_xenium_explorer.write_metadata).\n\n        - `morphology.ome.tif` is the primary image. This file can also be created with [`write_image`](./#spatialdata_xenium_explorer.write_image). Add more images with `align`.\n\n        - `analysis.zarr.zip` contains the cells categories (or clusters), i.e. `adata.obs`. This file can also be created with [`write_cell_categories`](./#spatialdata_xenium_explorer.write_cell_categories).\n\n        - `cell_feature_matrix.zarr.zip` contains the cell-by-gene counts. This file can also be created with [`write_gene_counts`](./#spatialdata_xenium_explorer.write_gene_counts).\n\n        - `cells.zarr.zip` contains the cells polygon boundaries. This file can also be created with [`write_polygons`](./#spatialdata_xenium_explorer.write_polygons).\n\n        - `transcripts.zarr.zip` contains transcripts locations. This file can also be created with [`write_transcripts`](./#spatialdata_xenium_explorer.write_transcripts).\n\n    Args:\n        path: Path to the directory where files will be saved.\n        sdata: A `SpatialData` object.\n        image_key: Name of the image of interest (key of `sdata.images`). This argument doesn't need to be provided if there is only one image.\n        shapes_key: Name of the cell shapes (key of `sdata.shapes`). This argument doesn't need to be provided if there is only one shapes key or a table with only one region.\n        points_key: Name of the transcripts (key of `sdata.points`). This argument doesn't need to be provided if there is only one points key.\n        gene_column: Column name of the points dataframe containing the gene names.\n        pixel_size: Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.\n        spot: Whether the technology is based on spots\n        layer: Layer of `sdata.table` where the gene counts are saved. If `None`, uses `sdata.table.X`.\n        polygon_max_vertices: Maximum number of vertices for the cell polygons. A higher value will display smoother cells.\n        lazy: If `True`, will not load the full images in memory (except if the image memory is below `ram_threshold_gb`).\n        ram_threshold_gb: Threshold (in gygabytes) from which image can be loaded in memory. If `None`, the image is never loaded in memory.\n        mode: string that indicated which files should be created. \"-ib\" means everything except images and boundaries, while \"+tocm\" means only transcripts/observations/counts/metadata (each letter corresponds to one explorer file). By default, keeps everything.\n    \"\"\"\n    path: Path = Path(path)\n    _check_explorer_directory(path)\n\n    image_key, image = utils.get_spatial_image(sdata, image_key, return_key=True)\n\n    ### Saving cell categories and gene counts\n    if sdata.table is not None:\n        adata = sdata.table\n\n        region = adata.uns[\"spatialdata_attrs\"][\"region\"]\n        region = region if isinstance(region, list) else [region]\n\n        if len(region) == 1:\n            assert (\n                shapes_key is None or shapes_key == region[0]\n            ), f\"Found only one region ({region[0]}), but `shapes_key` was provided with a different value ({shapes_key})\"\n            shapes_key = region[0]\n\n        if _should_save(mode, \"c\"):\n            write_gene_counts(path, adata, layer=layer)\n        if _should_save(mode, \"o\"):\n            write_cell_categories(path, adata)\n\n    ### Saving cell boundaries\n    shapes_key, geo_df = utils.get_element(sdata, \"shapes\", shapes_key, return_key=True)\n\n    if _should_save(mode, \"b\") and geo_df is not None:\n        geo_df = utils.to_intrinsic(sdata, geo_df, image_key)\n\n        if sdata.table is not None:\n            geo_df = geo_df.loc[adata.obs[adata.uns[\"spatialdata_attrs\"][\"instance_key\"]]]\n\n        geo_df = utils._standardize_shapes(geo_df)\n\n        write_polygons(path, geo_df.geometry, polygon_max_vertices, pixel_size=pixel_size)\n\n    ### Saving transcripts\n    if spot and sdata.table is not None:\n        df, gene_column = utils._spot_transcripts_origin(adata)\n    else:\n        df = utils.get_element(sdata, \"points\", points_key)\n        df = utils.to_intrinsic(sdata, df, image_key)\n\n    if _should_save(mode, \"t\") and df is not None:\n        if gene_column is not None:\n            write_transcripts(path, df, gene_column, pixel_size=pixel_size)\n        else:\n            log.warn(\"The argument 'gene_column' has to be provided to save the transcripts\")\n\n    ### Saving image\n    if _should_save(mode, \"i\"):\n        write_image(\n            path, image, lazy=lazy, ram_threshold_gb=ram_threshold_gb, pixel_size=pixel_size\n        )\n\n    ### Saving experiment.xenium file\n    if _should_save(mode, \"m\"):\n        write_metadata(path, image_key, shapes_key, _get_n_obs(sdata, geo_df), pixel_size)\n\n    log.info(f\"Saved files in the following directory: {path}\")\n    log.info(f\"You can open the experiment with 'open {path / FileNames.METADATA}'\")\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.write_image","title":"<code>spatialdata_xenium_explorer.write_image(path, image, lazy=True, tile_width=1024, n_subscales=5, pixel_size=0.2125, ram_threshold_gb=4, is_dir=True)</code>","text":"<p>Convert an image into a <code>morphology.ome.tif</code> file that can be read by the Xenium Explorer</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Xenium Explorer directory where the image will be written</p> required <code>image</code> <code>SpatialImage | ndarray</code> <p>Image of shape <code>(C, Y, X)</code></p> required <code>lazy</code> <code>bool</code> <p>If <code>False</code>, the image will not be read in-memory (except if the image size is below <code>ram_threshold_gb</code>). If <code>True</code>, all the images levels are always loaded in-memory.</p> <code>True</code> <code>tile_width</code> <code>int</code> <p>Xenium tile width (do not update).</p> <code>1024</code> <code>n_subscales</code> <code>int</code> <p>Number of sub-scales in the pyramidal image.</p> <code>5</code> <code>pixel_size</code> <code>float</code> <p>Xenium pixel size (do not update).</p> <code>0.2125</code> <code>ram_threshold_gb</code> <code>int | None</code> <p>If an image (of any level of the pyramid) is below this threshold, it will be loaded in-memory.</p> <code>4</code> <code>is_dir</code> <code>bool</code> <p>If <code>False</code>, then <code>path</code> is a path to a single file, not to the Xenium Explorer directory.</p> <code>True</code> Source code in <code>spatialdata_xenium_explorer/core/images.py</code> <pre><code>def write_image(\n    path: str,\n    image: SpatialImage | np.ndarray,\n    lazy: bool = True,\n    tile_width: int = 1024,\n    n_subscales: int = 5,\n    pixel_size: float = 0.2125,\n    ram_threshold_gb: int | None = 4,\n    is_dir: bool = True,\n):\n    \"\"\"Convert an image into a `morphology.ome.tif` file that can be read by the Xenium Explorer\n\n    Args:\n        path: Path to the Xenium Explorer directory where the image will be written\n        image: Image of shape `(C, Y, X)`\n        lazy: If `False`, the image will not be read in-memory (except if the image size is below `ram_threshold_gb`). If `True`, all the images levels are always loaded in-memory.\n        tile_width: Xenium tile width (do not update).\n        n_subscales: Number of sub-scales in the pyramidal image.\n        pixel_size: Xenium pixel size (do not update).\n        ram_threshold_gb: If an image (of any level of the pyramid) is below this threshold, it will be loaded in-memory.\n        is_dir: If `False`, then `path` is a path to a single file, not to the Xenium Explorer directory.\n    \"\"\"\n    path = utils.explorer_file_path(path, FileNames.IMAGE, is_dir)\n\n    if isinstance(image, np.ndarray):\n        assert len(image.shape) == 3, \"Can only write channels with shape (C,Y,X)\"\n        log.info(f\"Converting image of shape {image.shape} into a SpatialImage (with dims: C,Y,X)\")\n        image = SpatialImage(image, dims=[\"c\", \"y\", \"x\"], name=\"image\")\n\n    image: MultiscaleSpatialImage = to_multiscale(image, [2] * n_subscales)\n\n    image_writer = MultiscaleImageWriter(image, pixel_size=pixel_size, tile_width=tile_width)\n    image_writer.write(path, lazy=lazy, ram_threshold_gb=ram_threshold_gb)\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.write_cell_categories","title":"<code>spatialdata_xenium_explorer.write_cell_categories(path, adata, is_dir=True)</code>","text":"<p>Write a <code>analysis.zarr.zip</code> file containing the cell categories/clusters (i.e., from <code>adata.obs</code>)</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Xenium Explorer directory where the cell-categories file will be written</p> required <code>adata</code> <code>AnnData</code> <p>An <code>AnnData</code> object</p> required <code>is_dir</code> <code>bool</code> <p>If <code>False</code>, then <code>path</code> is a path to a single file, not to the Xenium Explorer directory.</p> <code>True</code> Source code in <code>spatialdata_xenium_explorer/core/table.py</code> <pre><code>def write_cell_categories(path: str, adata: AnnData, is_dir: bool = True) -&gt; None:\n    \"\"\"Write a `analysis.zarr.zip` file containing the cell categories/clusters (i.e., from `adata.obs`)\n\n    Args:\n        path: Path to the Xenium Explorer directory where the cell-categories file will be written\n        adata: An `AnnData` object\n        is_dir: If `False`, then `path` is a path to a single file, not to the Xenium Explorer directory.\n    \"\"\"\n    path = explorer_file_path(path, FileNames.CELL_CATEGORIES, is_dir)\n\n    adata.strings_to_categoricals()\n    cat_columns = [name for name, cat in adata.obs.dtypes.items() if cat == \"category\"]\n\n    log.info(f\"Writing {len(cat_columns)} cell categories: {', '.join(cat_columns)}\")\n\n    ATTRS = cell_categories_attrs()\n    ATTRS[\"number_groupings\"] = len(cat_columns)\n\n    with zarr.ZipStore(path, mode=\"w\") as store:\n        g = zarr.group(store=store)\n        cell_groups = g.create_group(\"cell_groups\")\n\n        for i, name in enumerate(cat_columns):\n            if adata.obs[name].isna().any():\n                NA = \"NA\"\n                log.warn(f\"Column {name} has nan values. They will be displayed as '{NA}'\")\n                adata.obs[name] = adata.obs[name].cat.add_categories(NA).fillna(NA)\n\n            categories = list(adata.obs[name].cat.categories)\n            ATTRS[\"grouping_names\"].append(name)\n            ATTRS[\"group_names\"].append(categories)\n\n            _write_categorical_column(cell_groups, i, adata.obs[name], categories)\n\n        cell_groups.attrs.put(ATTRS)\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.write_transcripts","title":"<code>spatialdata_xenium_explorer.write_transcripts(path, df, gene='gene', max_levels=15, is_dir=True, pixel_size=0.2125)</code>","text":"<p>Write a <code>transcripts.zarr.zip</code> file containing pyramidal transcript locations</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the Xenium Explorer directory where the transcript file will be written</p> required <code>df</code> <code>DataFrame</code> <p>DataFrame representing the transcripts, with <code>\"x\"</code>, <code>\"y\"</code> column required, as well as the <code>gene</code> column (see the corresponding argument)</p> required <code>gene</code> <code>str</code> <p>Column of <code>df</code> containing the genes names.</p> <code>'gene'</code> <code>max_levels</code> <code>int</code> <p>Maximum number of levels in the pyramid.</p> <code>15</code> <code>is_dir</code> <code>bool</code> <p>If <code>False</code>, then <code>path</code> is a path to a single file, not to the Xenium Explorer directory.</p> <code>True</code> <code>pixel_size</code> <code>float</code> <p>Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.</p> <code>0.2125</code> Source code in <code>spatialdata_xenium_explorer/core/points.py</code> <pre><code>def write_transcripts(\n    path: Path,\n    df: dd.DataFrame,\n    gene: str = \"gene\",\n    max_levels: int = 15,\n    is_dir: bool = True,\n    pixel_size: float = 0.2125,\n):\n    \"\"\"Write a `transcripts.zarr.zip` file containing pyramidal transcript locations\n\n    Args:\n        path: Path to the Xenium Explorer directory where the transcript file will be written\n        df: DataFrame representing the transcripts, with `\"x\"`, `\"y\"` column required, as well as the `gene` column (see the corresponding argument)\n        gene: Column of `df` containing the genes names.\n        max_levels: Maximum number of levels in the pyramid.\n        is_dir: If `False`, then `path` is a path to a single file, not to the Xenium Explorer directory.\n        pixel_size: Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.\n    \"\"\"\n    path = explorer_file_path(path, FileNames.POINTS, is_dir)\n\n    # TODO: make everything using dask instead of pandas\n    df = df.compute()\n\n    num_transcripts = len(df)\n    grid_size = ExplorerConstants.GRID_SIZE / ExplorerConstants.PIXELS_TO_MICRONS * pixel_size\n    df[gene] = df[gene].astype(\"category\")\n\n    location = df[[\"x\", \"y\"]]\n    location *= pixel_size\n    location = np.concatenate([location, np.zeros((num_transcripts, 1))], axis=1)\n\n    if location.min() &lt; 0:\n        log.warn(\"Some transcripts are located outside of the image (pixels &lt; 0)\")\n    log.info(f\"Writing {len(df)} transcripts\")\n\n    xmax, ymax = location[:, :2].max(axis=0)\n\n    gene_names = list(df[gene].cat.categories)\n    num_genes = len(gene_names)\n\n    codeword_gene_mapping = list(range(num_genes))\n\n    valid = np.ones((num_transcripts, 1))\n    uuid = np.stack([np.arange(num_transcripts), np.full(num_transcripts, 65535)], axis=1)\n    transcript_id = np.stack([np.arange(num_transcripts), np.full(num_transcripts, 65535)], axis=1)\n    gene_identity = df[gene].cat.codes.values[:, None]\n    codeword_identity = np.stack([gene_identity[:, 0], np.full(num_transcripts, 65535)], axis=1)\n    status = np.zeros((num_transcripts, 1))\n    quality_score = np.full((num_transcripts, 1), ExplorerConstants.QUALITY_SCORE)\n\n    ATTRS = {\n        \"codeword_count\": num_genes,\n        \"codeword_gene_mapping\": codeword_gene_mapping,\n        \"codeword_gene_names\": gene_names,\n        \"gene_names\": gene_names,\n        \"gene_index_map\": {name: index for name, index in zip(gene_names, codeword_gene_mapping)},\n        \"number_genes\": num_genes,\n        \"spatial_units\": \"micron\",\n        \"coordinate_space\": \"refined-final_global_micron\",\n        \"major_version\": 4,\n        \"minor_version\": 1,\n        \"name\": \"RnaDataset\",\n        \"number_rnas\": num_transcripts,\n        \"dataset_uuid\": \"unique-id-test\",\n        \"data_format\": 0,\n    }\n\n    GRIDS_ATTRS = {\n        \"grid_key_names\": [\"grid_x_loc\", \"grid_y_loc\"],\n        \"grid_zip\": False,\n        \"grid_size\": [grid_size],\n        \"grid_array_shapes\": [],\n        \"grid_number_objects\": [],\n        \"grid_keys\": [],\n    }\n\n    with zarr.ZipStore(path, mode=\"w\") as store:\n        g = zarr.group(store=store)\n        g.attrs.put(ATTRS)\n\n        grids = g.create_group(\"grids\")\n\n        for level in range(max_levels):\n            log.info(f\"   &gt; Level {level}: {len(location)} transcripts\")\n            level_group = grids.create_group(level)\n\n            tile_size = grid_size * 2**level\n\n            indices = np.floor(location[:, :2] / tile_size).clip(0).astype(int)\n            tiles_str_indices = np.array([f\"{tx},{ty}\" for (tx, ty) in indices])\n\n            GRIDS_ATTRS[\"grid_array_shapes\"].append([])\n            GRIDS_ATTRS[\"grid_number_objects\"].append([])\n            GRIDS_ATTRS[\"grid_keys\"].append([])\n\n            n_tiles_x, n_tiles_y = max(1, ceil(xmax / tile_size)), max(1, ceil(ymax / tile_size))\n\n            for tx in range(n_tiles_x):\n                for ty in range(n_tiles_y):\n                    str_index = f\"{tx},{ty}\"\n                    loc = np.where(tiles_str_indices == str_index)[0]\n\n                    n_points_tile = len(loc)\n                    chunks = (n_points_tile, 1)\n\n                    if n_points_tile == 0:\n                        continue\n\n                    GRIDS_ATTRS[\"grid_array_shapes\"][-1].append({})\n                    GRIDS_ATTRS[\"grid_keys\"][-1].append(str_index)\n                    GRIDS_ATTRS[\"grid_number_objects\"][-1].append(n_points_tile)\n\n                    tile_group = level_group.create_group(str_index)\n                    tile_group.array(\n                        \"valid\",\n                        valid[loc],\n                        dtype=\"uint8\",\n                        chunks=chunks,\n                    )\n                    tile_group.array(\n                        \"status\",\n                        status[loc],\n                        dtype=\"uint8\",\n                        chunks=chunks,\n                    )\n                    tile_group.array(\n                        \"location\",\n                        location[loc],\n                        dtype=\"float32\",\n                        chunks=chunks,\n                    )\n                    tile_group.array(\n                        \"gene_identity\",\n                        gene_identity[loc],\n                        dtype=\"uint16\",\n                        chunks=chunks,\n                    )\n                    tile_group.array(\n                        \"quality_score\",\n                        quality_score[loc],\n                        dtype=\"float32\",\n                        chunks=chunks,\n                    )\n                    tile_group.array(\n                        \"codeword_identity\",\n                        codeword_identity[loc],\n                        dtype=\"uint16\",\n                        chunks=chunks,\n                    )\n                    tile_group.array(\n                        \"uuid\",\n                        uuid[loc],\n                        dtype=\"uint32\",\n                        chunks=chunks,\n                    )\n                    tile_group.array(\n                        \"id\",\n                        transcript_id[loc],\n                        dtype=\"uint32\",\n                        chunks=chunks,\n                    )\n\n            if n_tiles_x * n_tiles_y == 1 and level &gt; 0:\n                GRIDS_ATTRS[\"number_levels\"] = level + 1\n                break\n\n            sub_indices = subsample_indices(len(location))\n\n            location = location[sub_indices]\n            valid = valid[sub_indices]\n            status = status[sub_indices]\n            gene_identity = gene_identity[sub_indices]\n            quality_score = quality_score[sub_indices]\n            codeword_identity = codeword_identity[sub_indices]\n            uuid = uuid[sub_indices]\n            transcript_id = transcript_id[sub_indices]\n\n        grids.attrs.put(GRIDS_ATTRS)\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.write_gene_counts","title":"<code>spatialdata_xenium_explorer.write_gene_counts(path, adata, layer=None, is_dir=True)</code>","text":"<p>Write a <code>cell_feature_matrix.zarr.zip</code> file containing the cell-by-gene transcript counts (i.e., from <code>adata.X</code>)</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Xenium Explorer directory where the cell-by-gene file will be written</p> required <code>adata</code> <code>AnnData</code> <p>An <code>AnnData</code> object. Note that <code>adata.X</code> has to be a sparse matrix (and contain the raw counts), else use the <code>layer</code> argument.</p> required <code>layer</code> <code>str | None</code> <p>If not <code>None</code>, <code>adata.layers[layer]</code> should be sparse (and contain the raw counts).</p> <code>None</code> <code>is_dir</code> <code>bool</code> <p>If <code>False</code>, then <code>path</code> is a path to a single file, not to the Xenium Explorer directory.</p> <code>True</code> Source code in <code>spatialdata_xenium_explorer/core/table.py</code> <pre><code>def write_gene_counts(\n    path: str, adata: AnnData, layer: str | None = None, is_dir: bool = True\n) -&gt; None:\n    \"\"\"Write a `cell_feature_matrix.zarr.zip` file containing the cell-by-gene transcript counts (i.e., from `adata.X`)\n\n    Args:\n        path: Path to the Xenium Explorer directory where the cell-by-gene file will be written\n        adata: An `AnnData` object. Note that `adata.X` has to be a sparse matrix (and contain the raw counts), else use the `layer` argument.\n        layer: If not `None`, `adata.layers[layer]` should be sparse (and contain the raw counts).\n        is_dir: If `False`, then `path` is a path to a single file, not to the Xenium Explorer directory.\n    \"\"\"\n    path = explorer_file_path(path, FileNames.TABLE, is_dir)\n\n    log.info(f\"Writing table with {adata.n_vars} columns\")\n    counts = adata.X if layer is None else adata.layers[layer]\n    counts = csr_matrix(counts.T)\n\n    feature_keys = list(adata.var_names) + [\"Total transcripts\"]\n    feature_ids = feature_keys\n    feature_types = [\"gene\"] * len(adata.var_names) + [\"aggregate_gene\"]\n\n    ATTRS = {\n        \"major_version\": 3,\n        \"minor_version\": 0,\n        \"number_cells\": adata.n_obs,\n        \"number_features\": adata.n_vars + 1,\n        \"feature_keys\": feature_keys,\n        \"feature_ids\": feature_ids,\n        \"feature_types\": feature_types,\n    }\n\n    total_counts = counts.sum(1).A1\n    loc = total_counts &gt; 0\n\n    data = np.concatenate([counts.data, total_counts[loc]])\n    indices = np.concatenate([counts.indices, np.where(loc)[0]])\n    indptr = counts.indptr\n    indptr = np.append(indptr, indptr[-1] + loc.sum())\n\n    cell_id = np.ones((adata.n_obs, 2))\n    cell_id[:, 0] = np.arange(adata.n_obs)\n\n    with zarr.ZipStore(path, mode=\"w\") as store:\n        g = zarr.group(store=store)\n        cells_group = g.create_group(\"cell_features\")\n        cells_group.attrs.put(ATTRS)\n\n        cells_group.array(\"cell_id\", cell_id, dtype=\"uint32\", chunks=cell_id.shape)\n        cells_group.array(\"data\", data, dtype=\"uint32\", chunks=data.shape)\n        cells_group.array(\"indices\", indices, dtype=\"uint32\", chunks=indices.shape)\n        cells_group.array(\"indptr\", indptr, dtype=\"uint32\", chunks=indptr.shape)\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.write_polygons","title":"<code>spatialdata_xenium_explorer.write_polygons(path, polygons, max_vertices, is_dir=True, pixel_size=0.2125)</code>","text":"<p>Write a <code>cells.zarr.zip</code> file containing the cell polygonal boundaries</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the Xenium Explorer directory where the transcript file will be written</p> required <code>polygons</code> <code>Iterable[Polygon]</code> <p>A list of <code>shapely</code> polygons to be written</p> required <code>max_vertices</code> <code>int</code> <p>The number of vertices per polygon (they will be transformed to have the right number of vertices)</p> required <code>is_dir</code> <code>bool</code> <p>If <code>False</code>, then <code>path</code> is a path to a single file, not to the Xenium Explorer directory.</p> <code>True</code> <code>pixel_size</code> <code>float</code> <p>Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.</p> <code>0.2125</code> Source code in <code>spatialdata_xenium_explorer/core/shapes.py</code> <pre><code>def write_polygons(\n    path: Path,\n    polygons: Iterable[Polygon],\n    max_vertices: int,\n    is_dir: bool = True,\n    pixel_size: float = 0.2125,\n) -&gt; None:\n    \"\"\"Write a `cells.zarr.zip` file containing the cell polygonal boundaries\n\n    Args:\n        path: Path to the Xenium Explorer directory where the transcript file will be written\n        polygons: A list of `shapely` polygons to be written\n        max_vertices: The number of vertices per polygon (they will be transformed to have the right number of vertices)\n        is_dir: If `False`, then `path` is a path to a single file, not to the Xenium Explorer directory.\n        pixel_size: Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.\n    \"\"\"\n    path = explorer_file_path(path, FileNames.SHAPES, is_dir)\n\n    log.info(f\"Writing {len(polygons)} cell polygons\")\n    coordinates = np.stack([pad_polygon(p, max_vertices) for p in polygons])\n    coordinates *= pixel_size\n\n    num_cells = len(coordinates)\n    cells_fourth = ceil(num_cells / 4)\n    cells_half = ceil(num_cells / 2)\n\n    GROUP_ATTRS = group_attrs()\n    GROUP_ATTRS[\"number_cells\"] = num_cells\n\n    polygon_vertices = np.stack([coordinates, coordinates])\n    num_points = polygon_vertices.shape[2]\n    n_vertices = num_points // 2\n\n    with zarr.ZipStore(path, mode=\"w\") as store:\n        g = zarr.group(store=store)\n        g.attrs.put(GROUP_ATTRS)\n\n        g.array(\n            \"polygon_vertices\",\n            polygon_vertices,\n            dtype=\"float32\",\n            chunks=(1, cells_fourth, ceil(num_points / 4)),\n        )\n\n        cell_id = np.ones((num_cells, 2))\n        cell_id[:, 0] = np.arange(num_cells)\n        g.array(\"cell_id\", cell_id, dtype=\"uint32\", chunks=(cells_half, 1))\n\n        cell_summary = np.zeros((num_cells, 7))\n        cell_summary[:, 2] = [p.area for p in polygons]\n        g.array(\n            \"cell_summary\",\n            cell_summary,\n            dtype=\"float64\",\n            chunks=(num_cells, 1),\n        )\n        g[\"cell_summary\"].attrs.put(cell_summary_attrs())\n\n        g.array(\n            \"polygon_num_vertices\",\n            np.full((2, num_cells), n_vertices),\n            dtype=\"int32\",\n            chunks=(1, cells_half),\n        )\n\n        g.array(\n            \"seg_mask_value\",\n            np.arange(num_cells),\n            dtype=\"uint32\",\n            chunks=(cells_half,),\n        )\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.write_metadata","title":"<code>spatialdata_xenium_explorer.write_metadata(path, image_key='NA', shapes_key='NA', n_obs=0, is_dir=True, pixel_size=0.2125)</code>","text":"<p>Create an <code>experiment.xenium</code> file that can be open by the Xenium Explorer.</p> Note <p>This function alone is not enough to actually open an experiment. You will need at least to wrun <code>write_image</code>, or create all the outputs with <code>write_explorer</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Xenium Explorer directory where the metadata file will be written</p> required <code>image_key</code> <code>str</code> <p>Key of <code>SpatialData</code> object containing the primary image used on the explorer.</p> <code>'NA'</code> <code>shapes_key</code> <code>str</code> <p>Key of <code>SpatialData</code> object containing the boundaries shown on the explorer.</p> <code>'NA'</code> <code>n_obs</code> <code>int</code> <p>Number of cells</p> <code>0</code> <code>is_dir</code> <code>bool</code> <p>If <code>False</code>, then <code>path</code> is a path to a single file, not to the Xenium Explorer directory.</p> <code>True</code> <code>pixel_size</code> <code>float</code> <p>Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.</p> <code>0.2125</code> Source code in <code>spatialdata_xenium_explorer/converter.py</code> <pre><code>def write_metadata(\n    path: str,\n    image_key: str = \"NA\",\n    shapes_key: str = \"NA\",\n    n_obs: int = 0,\n    is_dir: bool = True,\n    pixel_size: float = 0.2125,\n):\n    \"\"\"Create an `experiment.xenium` file that can be open by the Xenium Explorer.\n\n    Note:\n        This function alone is not enough to actually open an experiment. You will need at least to wrun `write_image`, or create all the outputs with `write_explorer`.\n\n    Args:\n        path: Path to the Xenium Explorer directory where the metadata file will be written\n        image_key: Key of `SpatialData` object containing the primary image used on the explorer.\n        shapes_key: Key of `SpatialData` object containing the boundaries shown on the explorer.\n        n_obs: Number of cells\n        is_dir: If `False`, then `path` is a path to a single file, not to the Xenium Explorer directory.\n        pixel_size: Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.\n    \"\"\"\n    path = utils.explorer_file_path(path, FileNames.METADATA, is_dir)\n\n    with open(path, \"w\") as f:\n        metadata = experiment_dict(image_key, shapes_key, n_obs, pixel_size)\n        json.dump(metadata, f, indent=4)\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.int_cell_id","title":"<code>spatialdata_xenium_explorer.int_cell_id(explorer_cell_id)</code>","text":"<p>Transforms an alphabetical cell id from the Xenium Explorer to an integer ID</p> <p>E.g., int_cell_id('aaaachba-1') = 10000</p> Source code in <code>spatialdata_xenium_explorer/utils.py</code> <pre><code>def int_cell_id(explorer_cell_id: str) -&gt; int:\n    \"\"\"Transforms an alphabetical cell id from the Xenium Explorer to an integer ID\n\n    E.g., int_cell_id('aaaachba-1') = 10000\"\"\"\n    code = explorer_cell_id[:-2] if explorer_cell_id[-2] == \"-\" else explorer_cell_id\n    coefs = [ord(c) - 97 for c in code][::-1]\n    return sum(value * 16**i for i, value in enumerate(coefs))\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.str_cell_id","title":"<code>spatialdata_xenium_explorer.str_cell_id(cell_id)</code>","text":"<p>Transforms an integer cell ID into an Xenium Explorer alphabetical cell id</p> <p>E.g., str_cell_id(10000) = 'aaaachba-1'</p> Source code in <code>spatialdata_xenium_explorer/utils.py</code> <pre><code>def str_cell_id(cell_id: int) -&gt; str:\n    \"\"\"Transforms an integer cell ID into an Xenium Explorer alphabetical cell id\n\n    E.g., str_cell_id(10000) = 'aaaachba-1'\"\"\"\n    coefs = []\n    for _ in range(8):\n        cell_id, coef = divmod(cell_id, 16)\n        coefs.append(coef)\n    return \"\".join([chr(97 + coef) for coef in coefs][::-1]) + \"-1\"\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.align","title":"<code>spatialdata_xenium_explorer.align(sdata, image, transformation_matrix_path, image_key=None, image_models_kwargs=None, overwrite=False)</code>","text":"<p>Add an image to the <code>SpatialData</code> object after alignment with the Xenium Explorer.</p> <p>Parameters:</p> Name Type Description Default <code>sdata</code> <code>SpatialData</code> <p>A <code>SpatialData</code> object</p> required <code>image</code> <code>SpatialImage</code> <p>A <code>SpatialImage</code> object. Note that <code>image.name</code> is used as the key for the aligned image.</p> required <code>transformation_matrix_path</code> <code>str</code> <p>Path to the <code>.csv</code> transformation matrix exported from the Xenium Explorer</p> required <code>image_key</code> <code>str</code> <p>Optional name of the image on which it has been aligned. Required if multiple images in the <code>SpatialData</code> object.</p> <code>None</code> <code>image_models_kwargs</code> <code>dict | None</code> <p>Kwargs to the <code>Image2DModel</code> model.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite the image, if already existing.</p> <code>False</code> Source code in <code>spatialdata_xenium_explorer/core/images.py</code> <pre><code>def align(\n    sdata: SpatialData,\n    image: SpatialImage,\n    transformation_matrix_path: str,\n    image_key: str = None,\n    image_models_kwargs: dict | None = None,\n    overwrite: bool = False,\n):\n    \"\"\"Add an image to the `SpatialData` object after alignment with the Xenium Explorer.\n\n    Args:\n        sdata: A `SpatialData` object\n        image: A `SpatialImage` object. Note that `image.name` is used as the key for the aligned image.\n        transformation_matrix_path: Path to the `.csv` transformation matrix exported from the Xenium Explorer\n        image_key: Optional name of the image on which it has been aligned. Required if multiple images in the `SpatialData` object.\n        image_models_kwargs: Kwargs to the `Image2DModel` model.\n        overwrite: Whether to overwrite the image, if already existing.\n    \"\"\"\n    image_name = image.name\n    image_models_kwargs = _default_image_models_kwargs(image_models_kwargs)\n\n    to_pixel = Affine(\n        np.genfromtxt(transformation_matrix_path, delimiter=\",\"),\n        input_axes=(\"x\", \"y\"),\n        output_axes=(\"x\", \"y\"),\n    )\n\n    default_image = utils.get_spatial_image(sdata, image_key)\n    pixel_cs = utils.get_intrinsic_cs(sdata, default_image)\n\n    image = Image2DModel.parse(\n        image,\n        dims=(\"c\", \"y\", \"x\"),\n        transformations={pixel_cs: to_pixel},\n        c_coords=image.coords[\"c\"].values,\n        **image_models_kwargs,\n    )\n\n    log.info(f\"Adding image {image.name}:\\n{image}\")\n    sdata.images[image_name] = image\n</code></pre>"},{"location":"api/#spatialdata_xenium_explorer.save_column_csv","title":"<code>spatialdata_xenium_explorer.save_column_csv(path, adata, key)</code>","text":"<p>Save one column of the AnnData object as a CSV that can be open interactively in the explorer, under the \"cell\" panel.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path where to write the CSV that will be open in the Xenium Explorer</p> required <code>adata</code> <code>AnnData</code> <p>An <code>AnnData</code> object</p> required <code>key</code> <code>str</code> <p>Key of <code>adata.obs</code> containing the column to convert</p> required Source code in <code>spatialdata_xenium_explorer/core/table.py</code> <pre><code>def save_column_csv(path: str, adata: AnnData, key: str):\n    \"\"\"Save one column of the AnnData object as a CSV that can be open interactively in the explorer, under the \"cell\" panel.\n\n    Args:\n        path: Path where to write the CSV that will be open in the Xenium Explorer\n        adata: An `AnnData` object\n        key: Key of `adata.obs` containing the column to convert\n    \"\"\"\n    df = pd.DataFrame({\"cell_id\": adata.obs_names, \"group\": adata.obs[key].values})\n    df.to_csv(path, index=None)\n</code></pre>"},{"location":"cite_us/","title":"Cite us","text":"<p>This library has been detailed in a more general article spatial omics analysis, see the Sopa library. The latter article is not published yet, but you can cite our preprint:</p> <pre><code>@article {Blampey2023.12.22.571863,\n    author = {Quentin Blampey &amp; Kevin Mulder et al.},\n    title = {Sopa: a technology-invariant pipeline for analyses of image-based spatial-omics},\n    elocation-id = {2023.12.22.571863},\n    year = {2023},\n    doi = {10.1101/2023.12.22.571863},\n    publisher = {Cold Spring Harbor Laboratory},\n    URL = {https://www.biorxiv.org/content/early/2023/12/23/2023.12.22.571863},\n    eprint = {https://www.biorxiv.org/content/early/2023/12/23/2023.12.22.571863.full.pdf},\n    journal = {bioRxiv}\n}\n</code></pre> <p>This library has been developed by Quentin Blampey, PhD student in Biomathematics / Deep Learning. The following institutions funded this work:</p> <ul> <li>Lab of Mathematics and Computer Science (MICS), CentraleSup\u00e9lec (Engineering School, Paris-Saclay University).</li> <li>PRISM center, Gustave Roussy Institute (Cancer campus, Paris-Saclay University).</li> </ul>"},{"location":"cli/","title":"CLI (command-line-interface)","text":""},{"location":"cli/#usage","title":"Usage","text":"<p>When installing <code>spatialdata_xenium_explorer</code> are written in our getting-started guidelines, a new command named <code>spatialdata_xenium_explorer</code> becomes available.</p> <p>CLI helper</p> <p>Run <code>spatialdata_xenium_explorer --help</code> to get details about all the command line purpose. You can also use this helper on any subcommand, for instance <code>spatialdata_xenium_explorer write --help</code>.</p> <pre><code>// Run the spatialdata_xenium_explorer CLI helper\n$ spatialdata_xenium_explorer --help\n Usage: spatialdata_xenium_explorer [OPTIONS] COMMAND [ARGS]...    \n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 write        Convertion: spatialdata to the Xenium Explorer \u2502\n\u2502 add-aligned  Add image after alignment on the explorer      \u2502\n\u2502 update-obs   Update the cell categories for the explorer    \u2502 \n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n// Example\n$ spatialdata_xenium_explorer write /path/to/sdata.zarr\n... [Logs] ...\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":"<p>Usage:</p> <pre><code>$ spatialdata_xenium_explorer [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul> <p>Commands:</p> <ul> <li><code>add-aligned</code>: After alignment on the Xenium Explorer,...</li> <li><code>update-obs</code>: Update the cell categories for the Xenium...</li> <li><code>write</code>: Convert a spatialdata object to Xenium...</li> </ul>"},{"location":"cli/#spatialdata_xenium_explorer-add-aligned","title":"<code>spatialdata_xenium_explorer add-aligned</code>","text":"<p>After alignment on the Xenium Explorer, add an image to the SpatialData object</p> <p>Usage:</p> <pre><code>$ spatialdata_xenium_explorer add-aligned [OPTIONS] SDATA_PATH IMAGE_PATH TRANSFORMATION_MATRIX_PATH\n</code></pre> <p>Arguments:</p> <ul> <li><code>SDATA_PATH</code>: Path to the SpatialData <code>.zarr</code> directory  [required]</li> <li><code>IMAGE_PATH</code>: Path to the image file to be added (<code>.ome.tif</code> used in the explorer during alignment)  [required]</li> <li><code>TRANSFORMATION_MATRIX_PATH</code>: Path to the <code>matrix.csv</code> file returned by the Explorer after alignment  [required]</li> </ul> <p>Options:</p> <ul> <li><code>--original-image-key TEXT</code>: Optional original-image key (of sdata.images) on which the new image will be aligned. This doesn't need to be provided if there is only one image</li> <li><code>--overwrite / --no-overwrite</code>: Whether to overwrite the image if existing  [default: no-overwrite]</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#spatialdata_xenium_explorer-update-obs","title":"<code>spatialdata_xenium_explorer update-obs</code>","text":"<p>Update the cell categories for the Xenium Explorer's (i.e. what's in <code>adata.obs</code>). This is useful when you perform analysis and update your <code>AnnData</code> object</p> <p>Usage</p> <p>This command should only be used if you updated <code>adata.obs</code>, after creation of the other explorer files.</p> <p>Usage:</p> <pre><code>$ spatialdata_xenium_explorer update-obs [OPTIONS] ADATA_PATH OUTPUT_PATH\n</code></pre> <p>Arguments:</p> <ul> <li><code>ADATA_PATH</code>: Path to the anndata file (<code>zarr</code> or <code>h5ad</code>) containing the new observations  [required]</li> <li><code>OUTPUT_PATH</code>: Path to the Xenium Explorer directory (it will update <code>analysis.zarr.zip</code>)  [required]</li> </ul> <p>Options:</p> <ul> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"cli/#spatialdata_xenium_explorer-write","title":"<code>spatialdata_xenium_explorer write</code>","text":"<p>Convert a spatialdata object to Xenium Explorer's inputs</p> <p>Usage:</p> <pre><code>$ spatialdata_xenium_explorer write [OPTIONS] SDATA_PATH\n</code></pre> <p>Arguments:</p> <ul> <li><code>SDATA_PATH</code>: Path to the SpatialData <code>.zarr</code> directory  [required]</li> </ul> <p>Options:</p> <ul> <li><code>--output-path TEXT</code>: Path to a directory where Xenium Explorer's outputs will be saved. By default, writes to the same path as <code>sdata_path</code> but with the <code>.explorer</code> suffix</li> <li><code>--image-key TEXT</code>: Name of the image of interest (key of <code>sdata.images</code>). This argument doesn't need to be provided if there is only one image.</li> <li><code>--shapes-key TEXT</code>: Name of the cell shapes (key of <code>sdata.shapes</code>). This argument doesn't need to be provided if there is only one shapes key or a table with only one region.</li> <li><code>--points-key TEXT</code>: Name of the transcripts (key of <code>sdata.points</code>). This argument doesn't need to be provided if there is only one points key.</li> <li><code>--gene-column TEXT</code>: Column name of the points dataframe containing the gene names</li> <li><code>--pixel_size FLOAT</code>: Number of microns in a pixel. Invalid value can lead to inconsistent scales in the Explorer.  [default: 0.2125]</li> <li><code>--spot / --no-spot</code>: Whether the technology is based on spots  [default: no-spot]</li> <li><code>--layer TEXT</code>: Layer of <code>sdata.table</code> where the gene counts are saved. If <code>None</code>, uses <code>sdata.table.X</code>.</li> <li><code>--lazy / --no-lazy</code>: If <code>True</code>, will not load the full images in memory (except if the image memory is below <code>ram_threshold_gb</code>)  [default: lazy]</li> <li><code>--ram-threshold-gb INTEGER</code>: Threshold (in gygabytes) from which image can be loaded in memory. If <code>None</code>, the image is never loaded in memory  [default: 4]</li> <li><code>--mode TEXT</code>: string that indicated which files should be created. <code>'-ib'</code> means everything except images and boundaries, while <code>'+tocm'</code> means only transcripts/observations/counts/metadata (each letter corresponds to one explorer file). By default, keeps everything</li> <li><code>--help</code>: Show this message and exit.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#installation","title":"Installation","text":"<p><code>spatialdata_xenium_explorer</code> can be installed on every OS with <code>pip</code> or <code>poetry</code> on <code>python&gt;=3.9</code>.</p> <p>Advice (optional)</p> <p>We advise creating a new environment via a package manager (except if you use Poetry, which will automatically create the environment).</p> <p>For instance, you can create a new <code>conda</code> environment:</p> <pre><code>conda create --name spatialdata_xenium_explorer python=3.10\nconda activate spatialdata_xenium_explorer\n</code></pre> <p>Choose one of the following, depending on your needs (it should take at most a few minutes):</p> From PyPIPip in dev modePoetry in dev mode <pre><code>pip install spatialdata_xenium_explorer\n</code></pre> <pre><code>git clone https://github.com/quentinblampey/spatialdata_xenium_explorer.git\ncd spatialdata_xenium_explorer\n\npip install -e .\n</code></pre> <pre><code>git clone https://github.com/quentinblampey/spatialdata_xenium_explorer.git\ncd spatialdata_xenium_explorer\n\npoetry install\n</code></pre>"},{"location":"getting_started/#usage","title":"Usage","text":"<p>You can choose between these two options:</p> <ul> <li>Our command-line-interface (CLI)</li> <li>Our python API</li> </ul>"}]}